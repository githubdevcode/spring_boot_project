USEFUL COMMANDS (19-08-2024)

1. Visual Studio
    * Como crear un proyecto de spring boot?
        - Windows
            1. Descargar e instalar un java jdk 
            2. Ingresar al ide visual studio
                1. Ir a Extensions
                2. Buscar e instalar
                  1. Extension Pack for Java
                  2. Spring boot tools
          3. Ir al cuadro de busqueda de archivos
          4. Seleccionar las opciones y diligenciar la informacion requerida
            1. Show and run commands
            2. Spring initializr: create a maven project
            3. Llenar el resto de informacion solicitada
2. Relativo a componentes
      * Controllers
         - Un controlador se encarga de recibir peticiones HTTP provenientes del
            frontend y de remitir esas peticiones a uno o mas servicios con
            el fin de llevar a cabo una logica del negocio cualquiera.
         - Un controlador puede contener una de dos anotaciones posibles dependiendo
            de su proposito:
               1. @RestController: Esta anotacion es utilizada para definir controladores
                     que se encargan de recibir respuestas HTTP de un frontend.
               2. @Controller: Esta anotacion es utilizada para definir controladores
                     que se encargan de recibir peticiones de otro tipo de componentes.
                     Por ejemplo, vistas jsp o thymeleaf.
         - Adicional
               1. Se puede utilizar la anotacion @CrossOrigin antes de una clase java
                     controladora para implementar una politica CORS (Cross Origin
                     Resource) con el fin permitir el acceso de otros dominios a los
                     recursos declarados.
      * Services
         - Un servicio encapsula toda la logica relativa a una entidad del dominio.
         - Un servicio no contiene algun estado.
         - Todos los metodos en un servicio son transaccionales, es decir, se deben
            anotar con la anotacion 
            @org.springframework.transaction.annotation.Transactional
         - Un servicio puede contener multiples objetos servicio con el de poder
            comunicarse para poder llevar a cabo cada logica del negocio que se
            encuentra en cada uno de sus metodos.
         - Se pueden inyectar diferentes beans necesarios para la ejeucion de los
            metodos de un servicio definiendolos como parametros de un constructor.
      * Repositories
         - Un repositorio encapsula todos los metodos de acceso a datos relativos
            a un objeto del dominio.
         - Un repositorio puede extender alguna de las dos interfaces del framework 
            spring data con el fin de heredar diferentes metodos de acceso a datos.
               1. CrudRepository: Es una interfaz que contiene metodos basicos de
                     acceso a datos.
               2. JpaRepository: Es una interfaz que contiene los metodos de
                     acceso a datos que se encuentran en la interfaz CrudRepository
                     y adicionalmente agrega metodos para paginar filas y ordenarlas.

3. Paginacion
      * Retorno
         - Explicacion
            % Es un documento json que consiste de multiples partes:
               1. totalPages: Es el numero total de paginas las cuales contienen cada uno de los objetos
                     provenientes de la base de datos.
               2. totalElements: Es el numero total de objetos que se encuentran en la base de datos.
               3. size: Es el tamaño maximo de cada pagina.
               4. content: Contiene todos objetos provenientes de la base de datos.
               5. number: Es el numero de la pagina actual.
               6. sort: Contiene atributos que indican si la pagina se encuentran organizadas.
               7. first: Indica si la pagina devuelta contiene el ultimo objeto.
               8. last: Indica si la pagina devuelta contiene el primer objeto.
               9. numberOfElements: Es el numero total de elementos en el atributo content.
               10. pageable: Es un atributo que contiene atributos sobre la pagina actual.
                     & Atributos
                        1. pageNumber: Indica el numero de la pagina actual.
                        2. pageSize: Indica el tamaño total de cada pagina.
                        3. sort: Contiene atributos que indican si la pagina se encuentra organizada.
                        4. offset: Es un numero el cual indica la posicion desde la cual se empiezan a
                              obtener registros en una consulta. Este atributo esta relacionado con la
                              clausula LIMIT.
               11. empty: Es un atributo que indica si la pagina esta vacia o no lo esta.
4. Spring Security
      * Como implementar spring security en nuestro proyecto?
         1° Maven
            - Dependencia
               % <dependency>
            			<groupId>org.springframework.boot</groupId>
            			<artifactId>spring-boot-starter-security</artifactId>
            	  </dependency>
         2° Configuracion
            - Ejemplo de configuracion
               % Clase de configuracion
   
                  import org.springframework.beans.factory.annotation.Autowired;
                  import org.springframework.context.annotation.Bean;
                  import org.springframework.context.annotation.Configuration;
                  import org.springframework.http.HttpMethod;
                  import org.springframework.security.authentication.AuthenticationManager;
                  import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
                  import org.springframework.security.config.annotation.web.builders.HttpSecurity;
                  import org.springframework.security.config.http.SessionCreationPolicy;
                  import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
                  import org.springframework.security.crypto.password.PasswordEncoder;
                  import org.springframework.security.web.SecurityFilterChain;
                  
                  import com.springboot.backend.andres.userapp.usersbackend.users_backend.auth.filter.JwtAuthenticationFilter;
   
                  @Configuration
                  public class SpringSecurityConfig {

                     @Autowired
                  	private AuthenticationConfiguration authenticationConfiguration;
                  	
                  	@Bean
                  	AuthenticationManager authenticationManager() throws Exception {
                  		return authenticationConfiguration.getAuthenticationManager();
                  	}
                  	
                  	@Bean
                  	PasswordEncoder passwordEncoder() {
                  		return new BCryptPasswordEncoder();
                  	}
                     
                     @Bean
                  	SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
                  		return http
                     				.authorizeHttpRequests(
                     						authz -> authz.requestMatchers(HttpMethod.GET, "/api/users", "/api/users/page/{page}")
                     								.permitAll().requestMatchers(HttpMethod.GET, "/api/users/{id}")
                     								.hasAnyRole("USER", "ADMIN").requestMatchers(HttpMethod.POST, "/api/users")
                     								.hasAnyRole("ADMIN").requestMatchers(HttpMethod.PUT, "/api/users/{id}")
                     								.hasAnyRole("ADMIN").requestMatchers(HttpMethod.DELETE, "/api/users/{id}")
                     								.hasAnyRole("ADMIN").anyRequest().authenticated())
                     				.addFilter(new JwtAuthenticationFilter(authenticationManager()))
                     				.csrf(config -> config.disable())
                     				.sessionManagement(management -> management.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                     				.build();
                  	}
                  }
               % Explicacion
                  1. Se autorizan dos solicitudes http a varias url diferentes como "/api/users" o "/api/users/page/{page}".
                     Ademas se autorizan varias solicitudes http adicionales si el usuario tiene rol USER o ADMIN o ambos.
                     El resto de las solicitudes son permitidas solo si el usuario se encuentra autenticado.
                  2. Se inhabilita la gestion de una vulnerabilidad por parte de spring security llamada ataque de sitio 
                     cruzado la cual fuerza a un usuario autenticado en una aplicacion a realizar acciones no deseadas
                     como transferir fondos, etc.. Por ejemplo, un atacante inyecta una etiqueta html img en un campo de
                     texto que acepta html en una pagina html de manera que un usuario autenticado puede comprometer sus
                     credenciales.
                  3. Se indica a spring security que no cree un objeto HttpSession para almacenar la autenticacion de un
                     usuario entre solicitudes http sino que por cada solicitud http se autentique al usuario.
      * Autenticacion con JWT Authentication Filter
         - Cosas importantes
            1. La clase JwtAuthenticationFilter por debajo llama a la clase JpaUserDetailsService para con el fin de poder 
               autenticar el usuario que es descrito por las credenciales recibidas que se encuentran en el objeto User.
               El usuario y la contraseña en el objeto User son comparados con las del usuario que se encuentra en la
               base de datos. Si las ambas credenciales coinciden se genera un token JWT y es entregado al usuario en el
               cliente del frontend de lo contrario se envia un mensaje de error al cliente del frontend.
                  - NOTA: La clase JwtAuthenticationFilter es una implementacion de la clase UsernamePasswordAuthenticationFilter
                     el cual se ejecuta cada vez que se envia una solicitud http al endpoint /login
            2. Relativo a metodos
                  1. En el metodo JwtAuthenticationFilter.attemptAuthentication se extraen las credenciales del usuario como
                     el usuario y la contraseña y se procede a autenticar el usuario por medio de la comparacion con el usuario
                     en la base de datos.
                        & NOTA: Por debajo se llama al metodo JpaUserDetailsService.loadUserByUsername para obtener el usuario
                           de la base de datos, comparar datos del usuario de la base de datos como el nombre de usuario y la 
                           contraseña con las credenciales enviadas desde el cliente y generar un token jwt si las credenciales
                           obtenidas desde el cliente son validas.
                  2. En el metodo JwtAuthenticationFilter.successfulAuthentication se declara la logica relativa a la generacion
                     del token jwt por medio del uso de la libreria jjwt. El token jwt generado se devuelve al cliente para
                     que pueda utilizarlo en solicitudes http siguientes.
                     & NOTA: La generacion de la llave secreta que es utilizada en la creacion del token jwt es puesta en la
                        clase TokenJwtConfig debido a que la llave secreta es utilizada tanto en la creacion del token jwt
                        como en su validacion.
                  3. En el metodo JwtAuthenticationFilter.unsuccessfulAuthentication se declara la logica relativa a la generacion
                     de una respuesta de error cuando las credenciales de un usuario son invalidas.
            3. Las dependencias necesarias para que la libreria jwt funcione en nuestro proyecto maven de java son las
               siguientes:
                  & pom.xml
                     @ <dependency>
               			<groupId>io.jsonwebtoken</groupId>
               			<artifactId>jjwt-api</artifactId>
               			<version>0.12.6</version>
               		 </dependency>
               		 <dependency>
               			<groupId>io.jsonwebtoken</groupId>
               			<artifactId>jjwt-impl</artifactId>
               			<version>0.12.6</version>
               			<scope>runtime</scope>
               		 </dependency>
               		 <dependency>
               			<groupId>io.jsonwebtoken</groupId>
               			<artifactId>jjwt-jackson</artifactId> <!-- or jjwt-gson if Gson is
               			preferred -->
               			<version>0.12.6</version>
               			<scope>runtime</scope>
               		 </dependency>
      * Autenticacion con JWT Validation Filter
         - Cosas importantes
            1. El metodo JwtValidationFilter.doFilterInternal se encarga de contener la logica relativa a la validacion de tokens 
               jwt los cuales se encuentran en la cabecera Authorization en cada solicitud http que intente acceder a un recurso 
               protegido como puede ser un endpoint rest. Cada token jwt es validado con una llave secreta jwt global. Una vez
               que el token es validado se extraen las diferentes propiedades que se encuentran en el documento json del token
               jwt.
                  - NOTA: La clase JwtValidationFilter es la implementacion de un filtro el cual es llamado BasicAuthenticationFilter
                     el cual se ejecuta cada vez que en una solicitud http viene incluida la cabecera Authorization.
